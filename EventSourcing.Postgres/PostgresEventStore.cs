using EventSourcing.Abstractions;
using Microsoft.EntityFrameworkCore;
using System.Reflection;
using System.Text.Json;

namespace EventSourcing.Postgres;

internal class PostgresEventStore : IEventStore
{
    private readonly EventStoreDbContext _context;
    private readonly JsonSerializerOptions _jsonOptions;

    public PostgresEventStore(EventStoreDbContext context)
    {
        _context = context;
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
    }

    public async Task SaveEventsAsync(Guid streamId, IEnumerable<AggregateChange> events, long expectedVersion, CancellationToken cancellationToken = default)
    {
        var strategy = _context.Database.CreateExecutionStrategy();

        await strategy.ExecuteAsync(async () =>
        {
            await using var transaction = await _context.Database.BeginTransactionAsync(cancellationToken);

            try
            {
                var eventEntities = await PrepareEventEntitiesAsync(streamId, events, expectedVersion, cancellationToken);

                _context.Events.AddRange(eventEntities);
                await _context.SaveChangesAsync(cancellationToken);
                await transaction.CommitAsync(cancellationToken);
            }
            catch (Exception)
            {
                await transaction.RollbackAsync(cancellationToken);
                throw;
            }
        });
    }

    public async Task SaveEventsBatchAsync(IEnumerable<AggregateRoot> aggregates, CancellationToken cancellationToken = default)
    {
        var strategy = _context.Database.CreateExecutionStrategy();

        await strategy.ExecuteAsync(async () =>
        {
            await using var transaction = await _context.Database.BeginTransactionAsync(cancellationToken);

            try
            {
                foreach (var aggregate in aggregates)
                {
                    var eventEntities = await PrepareEventEntitiesAsync(streamId: aggregate.Id, aggregate.UncommittedEvents, aggregate.ExpectedVersion, cancellationToken);
                    _context.Events.AddRange(eventEntities);
                    await _context.SaveChangesAsync(cancellationToken);
                }

                // Save all changes in a single transaction
                await transaction.CommitAsync(cancellationToken);
            }
            catch (Exception)
            {
                await transaction.RollbackAsync(cancellationToken);
                throw;
            }
        });
    }

    public async Task<IEnumerable<AggregateChange>> GetEventsAsync(Guid streamId, CancellationToken cancellationToken = default)
    {
        return await GetEventsAsync(streamId, fromVersion: 0, cancellationToken);
    }

    public async Task<IEnumerable<AggregateChange>> GetEventsAsync(Guid streamId, long fromVersion, CancellationToken cancellationToken = default)
    {
        var eventEntities = await _context.Events
            .Where(e => e.StreamId == streamId && 
                        e.Version > fromVersion && 
                       !e.IsArchived)
            .OrderBy(e => e.Version)
            .ToListAsync(cancellationToken);

        var events = new List<AggregateChange>();
        
        foreach (var eventEntity in eventEntities)
        {
            var domainEvent = DeserializeEvent(eventEntity);
            if (domainEvent is not null)
            {
                var change = new AggregateChange(
                    domainEvent,
                    eventEntity.Id,
                    domainEvent.GetType(),
                    eventEntity.Version,
                    eventEntity.Timestamp);
                events.Add(change);
            }
        }
        
        return events;
    }

    private async Task<IEnumerable<EventEntity>> PrepareEventEntitiesAsync(Guid streamId, IEnumerable<AggregateChange> events, long expectedVersion, CancellationToken cancellationToken)
    {
        // Check current version
        var currentVersion = await GetCurrentVersionAsync(streamId, cancellationToken);

        if (currentVersion != expectedVersion)
        {
            throw new InvalidOperationException($"Concurrency conflict. Expected version {expectedVersion}, but current version is {currentVersion}");
        }

        var eventEntities = new List<EventEntity>();

        foreach (var change in events)
        {
            var eventData = JsonSerializer.Serialize(change.Content, change.Type, _jsonOptions);
            var jsonDocument = JsonDocument.Parse(eventData);

            var eventEntity = new EventEntity
            {
                SeqId = 0, // This will be auto-generated by the database sequence
                Id = change.Id,
                StreamId = streamId,
                Version = change.Version,
                Data = jsonDocument,
                Type = change.Type.Name,
                Timestamp = change.CreatedAt,
                MtDotnetType = change.Content.GetType().AssemblyQualifiedName,
                TenantId = "*DEFAULT*",
                IsArchived = false
            };

            eventEntities.Add(eventEntity);
        }

        return eventEntities;
    }

    private async Task<long> GetCurrentVersionAsync(Guid streamId, CancellationToken cancellationToken = default)
    {
        var maxVersion = await _context.Events
            .Where(e => e.StreamId == streamId && !e.IsArchived)
            .MaxAsync(e => (long?)e.Version, cancellationToken);
        
        return maxVersion ?? 0;
    }

    private object? DeserializeEvent(EventEntity eventEntity)
    {
        try
        {
            var eventData = eventEntity.Data.RootElement.GetRawText();
            
            // Try to resolve the type from the current assembly and referenced assemblies
            var eventType = ResolveEventType(eventEntity.Type, eventEntity.MtDotnetType);
            
            if (eventType is not null)
            {
                return JsonSerializer.Deserialize(eventData, eventType, _jsonOptions);
            }

            Console.WriteLine($"Could not resolve event type: {eventEntity.Type}");
            return null;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to deserialize event: {ex.Message}");
            return null;
        }
    }

    private static Type? ResolveEventType(string typeName, string? assemblyQualifiedName)
    {
        // First try the assembly qualified name if available
        if (!string.IsNullOrEmpty(assemblyQualifiedName))
        {
            var type = Type.GetType(assemblyQualifiedName);
            if (type is not null)
                return type;
        }

        // Try to find the type in loaded assemblies
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        
        foreach (var assembly in assemblies)
        {
            try
            {
                var types = assembly.GetTypes();
                var matchingType = types.FirstOrDefault(t => t.Name == typeName);
                if (matchingType is not null)
                    return matchingType;
            }
            catch (ReflectionTypeLoadException)
            {
                // Skip assemblies that can't be loaded
                continue;
            }
        }

        return null;
    }
}
